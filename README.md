gocog - generate code for any language, with any language
=====

gocog is a command line executable that processes in-line code in a file and outputs the results into the same file.

Design of gocog is heavily based on cog.py <http://nedbatchelder.com/code/cog/>.  Many thanks to Ned Batchelder for a really great design.

    Usage:
      gocog [OPTIONS] [INFILE1 | @FILELIST1] ...
      
      Runs gocog over each infile. 
      Files prepended with @ are read as newline delimited lists of files to be processed
    
    Help Options:
      -h, --help    Show this help message
    
    Application Options:
      -z        The [[[end]]] marker can be omitted, and is assumed at eof.
      -v        toggles verbose output (overridden by -q)
      -q        turns off all output
      -S        Write to the specified cog files serially (default is concurrent)

How it works
------

Code is embedded in comments in the given files, delimited thusly:

    [[[gocog
      <source code that will be run to generate output>
    gocog]]]
    [[[end]]]

Anything written to standard out from the sourcecode will be injected between gocog]]] and [[[end]]]

The source code embedded in the file is written out to a temporary file on disk by gocog named filename_cog.ext (where filename is the original filename, and ext is the appropriate extension for the generator language (right now limited to Go). This file is then run using the specified command line tool (right now limited to "go run").  Standard output generated by the generator code is piped to a new file named filename_cog, along with the original text. If generation is successful for all gocog blocks in a file, this output file is then used to replace the original file.

If at any time there is an error while running gocog over a file, the original file is not replaced. Errors from the generator code will be piped to gocog's stderr.

By default, each file is processed in parallel, to speed the processing of large numbers of files.

The gocog marker tags can be preceded by any text (such as comment tags to prevent your compiler/interpreter from barfing on them).

You can rerun gocog over the same file multiple times. Previously generated text will be discarded and replaced by the newly generated text.

You can have multiple blocks of gocog generator code inside the same file.

Current Limitations
----------

* Only supports the Go programming language as generator code
* Command line is hard coded to "go run output_file.go"
* All marker tags must be on different lines
* No support for single line comment tags in front of the sourcecode 

Todo
----
Gocog is a work in progress. Here's some stuff I'll be adding soon

* Support for any source code language and any command line
* Support for sourcecode prefixed with the single line comment tags (instead of requring multiline)
* Support for single line gocog statements
* Anything commented out in options.go <https://github.com/NateFinch/gocog/blob/master/process/options.go>\
* Better support for correct indentation
* Pre and post-run commands
* Support for running across an entire directory / tree
* Configuration file for saving extensive gocog config settings
* Support for standardized header and footer text for generated sourcecode (to remove boilerplate)
* Support for running different generator blocks in the same file in parallel (currently they're run serially)

Example
------
Using generator code written in Go to write out properties for a C# class

    using System;
    
    namespace foo 
    {
      public class Foo
      {
        /* [[[gocog
        package main
        import "fmt"
        func main() {
          for _, s := range []string{ "Bar", "Baz", "Bat", "Stuff" } {
            fmt.Printf("\t\tpublic String %s { get; set; }\n", s)
          }
        }
        gocog]]]  */
        // [[[end]]]
      }
    }

Output:

    using System;
    
    namespace foo 
    {
      public class Foo
      {
        /* [[[gocog
        package main
        import "fmt"
        func main() {
          for _, s := range []string{ "Bar", "Baz", "Bat", "Stuff" } {
            fmt.Printf("\t\tpublic String %s { get; set; }\n", s)
          }
        }
        gocog]]]  */
        public String Bar { get; set; }
        public String Baz { get; set; }
        public String Bat { get; set; }
        public String Stuff { get; set; }
        // [[[end]]]
      }
    }

Things to note:
The generator code and gocog markers are all hidden from the original file's compiler by comments, so the file is always valid.

The generator code stays in the file even after running through gocog. This keeps the sourcecode and the target close together so there's no need to worry about one getting lost. It also makes it a lot more clear where and how the output will be used in the original file.
